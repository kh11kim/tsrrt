import numpy as np
from tsrrt.data_structure import NodeJoint, Tree
from spatial_math_mini import SO3, SE3
import datetime

class RRT:
    def __init__(self, start, goal, checker):
        self._tree = Tree(start)
        self._start = start
        self._goal = goal
        self._last_node = None
        self._node_class = type(start)
        self._checker = checker
        
        self._goal_bias = 0.05
        
    def extend(self, node_rand):
        node_near = self._tree.nearest(node_rand)
        if self._node_class.distance(node_rand, node_near) < self._node_class.eps:
            # same node
            return
        #node_list = self._node_class.interpolate(node_near, node_rand)
        parent = node_near
        node_new, is_stop = self._node_class.control(parent, node_rand, self._checker)
        #for node in node_list[1:]:
        while node_new != node_rand:
            if (not node_new.is_valid(self._checker)) | is_stop:
                break
            self._tree.add(parent, node_new)
            
            if (self._node_class.distance(self._goal, node_new) <= self._node_class.eps):
                self._last_node = node_new
                break
            parent = node_new
            node_new, is_stop = self._node_class.control(parent, node_rand, self._checker)
    
    def is_goal_found(self):
        return self._last_node is not None
    
    def plan(self, max_time=5.0):
        self._last_node = None
        start_time = datetime.datetime.now()
        while not self.is_goal_found():
            if np.random.random() > self._goal_bias:
                node_rand = self._node_class.random()
            else:
                node_rand = self._goal
            self.extend(node_rand)

            time_delta = (datetime.datetime.now() - start_time)
            elapsed = time_delta.seconds + 0.000001 * time_delta.microseconds
            if elapsed > max_time:
                break

        if self.is_goal_found():
            print("planning success")
        else:
            print("planning fail")
        print("elapsed time : {}".format(elapsed))
        print("nodes:{}".format(self._tree._num))
        return self.is_goal_found(), self.path()

    def path(self):
        if not self.is_goal_found():
            return []
        path = [self._last_node]
        child_idx = self._last_node.idx
        while True:
            parent_idx = self._tree._parent_of[child_idx]
            if parent_idx is None:
                break
            path.append(self._tree._data[parent_idx])
            child_idx = parent_idx
        return path[::-1]

    def reset(self):
        self._tree = Tree(self._start)
        self._last_node = None